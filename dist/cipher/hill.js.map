{"version":3,"sources":["../../src/cipher/hill.js"],"names":["M","ACode","XOffset","mod26","x","getLats","inputs","lats","index","length","push","slice","last","left","char2Offset","offset2Char","String","fromCharCode","num2char","inverse","key","detK","rev","Number","isNaN","adj","hill","K","plaintext","toUpperCase","split","filter","map","P","lat","join","default"],"mappings":";;;;;;;AAKA;;AACA;;AANA;;;;;AAQA,MAAMA,IAAI,CAAV;AACA,MAAMC,QAAQ,kBAAO,GAAP,CAAd;AACA,MAAMC,UAAU,kBAAO,GAAP,IAAcD,KAA9B;;AAEA;;;;AAIA,MAAME,QAAQC,KAAK,eAAIA,CAAJ,EAAO,EAAP,CAAnB;;AAEA;;;;AAIA,MAAMC,UAAWC,MAAD,IAAY;AAC1B,QAAMC,OAAO,EAAb;AACA,MAAIC,KAAJ;AACA,OAAKA,QAAQ,CAAb,EAAgBA,QAAQR,CAAR,GAAY,CAAZ,GAAgBM,OAAOG,MAAvC,EAA+CD,SAASR,CAAxD,EAA2D;AACzDO,SAAKG,IAAL,CAAUJ,OAAOK,KAAP,CAAaH,KAAb,EAAoBA,QAAQR,CAA5B,CAAV;AACD;AACD,MAAIQ,QAAQF,OAAOG,MAAnB,EAA2B;AACzB,UAAMG,OAAON,OAAOK,KAAP,CAAaH,KAAb,CAAb;AACA,QAAIK,OAAOb,IAAIY,KAAKH,MAApB;AACA,WAAOI,IAAP,EAAa;AACXA,cAAQ,CAAR;AACAD,WAAKF,IAAL,CAAUR,OAAV;AACD;AACDK,SAAKG,IAAL,CAAUE,IAAV;AACD;AACD,SAAOL,IAAP;AACD,CAhBD;;AAkBA;;;;AAIA,MAAMO,cAAcV,KAAK,kBAAOA,CAAP,IAAYH,KAArC;;AAEA;;;;AAIA,MAAMc,cAAcX,KAAKY,OAAOC,YAAP,CAAoBb,IAAIH,KAAxB,CAAzB;;AAEA;;;;AAIA,MAAMiB,WAAWd,KAAKW,YAAYZ,MAAMC,CAAN,CAAZ,CAAtB;;AAEA;;;;AAIA,SAASe,OAAT,CAAiBC,GAAjB,EAAsB;AACpB,QAAMC,OAAO,eAAI,iBAAID,GAAJ,CAAJ,EAAc,EAAd,CAAb;AACA,QAAME,MAAM,sBAAWD,IAAX,EAAiB,EAAjB,CAAZ;AACA,MAAIE,OAAOC,KAAP,CAAaF,GAAb,CAAJ,EAAuB,OAAO,IAAP;AACvB,QAAMG,MAAM,sBAASL,GAAT,CAAZ;AACA,SAAO,iBAAIK,GAAJ,EAASrB,KAAK,eAAIA,IAAIkB,GAAR,EAAa,EAAb,CAAd,CAAP;AACD;;AAED;;;;AAIA,SAASI,IAAT,CAAcC,CAAd,EAAiBC,SAAjB,EAA4B;AAC1B,QAAMtB,SAASU,OAAOY,SAAP,EAAkBC,WAAlB,GAAgCC,KAAhC,CAAsC,EAAtC,EAA0CC,MAA1C,oBACZC,GADY,CACRlB,WADQ,CAAf;AAEA,QAAMmB,IAAI,uBAAU5B,QAAQC,MAAR,CAAV,CAAV;AACA,SAAO2B,IAAI,uBAAU,sBAASN,CAAT,EAAYM,CAAZ,CAAV,EAA0BD,GAA1B,CAA8BE,OAAOA,IAAIF,GAAJ,CAAQd,QAAR,EAAkBiB,IAAlB,CAAuB,EAAvB,CAArC,EAAiEA,IAAjE,CAAsE,EAAtE,CAAJ,GAAgF,EAAvF;AACD;;AAEDT,KAAKP,OAAL,GAAeA,OAAf;;QAEiBiB,O,GAARV,I;QAAiBP,O,GAAAA,O","file":"hill.js","sourcesContent":["/**\n * @typedef {number[][]} Matrix\n * @typedef {number[]} Lat\n */\n\nimport { transpose, multiply, map, det, adjugate } from '../matrix'\nimport { isUpperCase, mod, modInverse, codeOf } from '../util'\n\nconst M = 3\nconst ACode = codeOf('A')\nconst XOffset = codeOf('X') - ACode\n\n/**\n * @param {number} x\n * @returns {number}\n */\nconst mod26 = x => mod(x, 26)\n\n/**\n * @param {Lat} inputs\n * @returns {Matrix}\n */\nconst getLats = (inputs) => {\n  const lats = []\n  let index\n  for (index = 0; index + M - 1 < inputs.length; index += M) {\n    lats.push(inputs.slice(index, index + M))\n  }\n  if (index < inputs.length) {\n    const last = inputs.slice(index)\n    let left = M - last.length\n    while (left) {\n      left -= 1\n      last.push(XOffset)\n    }\n    lats.push(last)\n  }\n  return lats\n}\n\n/**\n * @param {string} x\n * @returns {number}\n */\nconst char2Offset = x => codeOf(x) - ACode\n\n/**\n * @param {number} x\n * @returns {string}\n */\nconst offset2Char = x => String.fromCharCode(x + ACode)\n\n/**\n * @param {number} x\n * @returns {string}\n */\nconst num2char = x => offset2Char(mod26(x))\n\n/**\n * @param {Matrix} key\n * @returns {Matrix}\n */\nfunction inverse(key) {\n  const detK = mod(det(key), 26)\n  const rev = modInverse(detK, 26)\n  if (Number.isNaN(rev)) return null\n  const adj = adjugate(key)\n  return map(adj, x => mod(x * rev, 26))\n}\n\n/**\n * @param {Matrix} K\n * @param {string} plaintext\n */\nfunction hill(K, plaintext) {\n  const inputs = String(plaintext).toUpperCase().split('').filter(isUpperCase)\n    .map(char2Offset)\n  const P = transpose(getLats(inputs))\n  return P ? transpose(multiply(K, P)).map(lat => lat.map(num2char).join('')).join('') : ''\n}\n\nhill.inverse = inverse\n\nexport { hill as default, inverse }\n"]}